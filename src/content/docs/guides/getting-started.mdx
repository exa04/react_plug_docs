---
title: Getting Started
description: Building your first React-Plug plugin
---

import { Aside, FileTree } from "@astrojs/starlight/components";

<Aside type="caution" title="API Stability">
  The API of React-Plug is still very unstable. Some of these code snippets
  might end up being outdated.
</Aside>

This guide offers a fairly detailed look at React-Plug's basic concepts. It's assumed that you already know the very basics of <a target="_blank" href="https://github.com/robbert-vdh/nih-plug">nih-plug</a> and <a target="_blank" href="https://reactjs.org">React</a> going into this.

After [generating a new plugin](/guides/quick-start), change directories into your freshly generated plugin.

## Plugin

The main plugin code is inside the `src/` directory. Let's see what we can do with the generated code.

<FileTree>

- gui/
- **src/** Plugin code
  - lib.rs
  - params.rs
- xtask/

</FileTree>

### Parameters

Let's take a look at the parameters. They're defined in `src/params.rs`.

<FileTree>

- gui/
- src/ Plugin code
  - lib.rs
  - **params.rs**
- xtask/

</FileTree>

For convenience, the parameters of a React-Plug plugin are declared using a macro that takes care of a lot of the boilerplate that would usually come with a WebView plugin. You can define your parameters once using a domain specific language - the `rp-params!` macro then handles all the fluff.

Let's add a `muted` parameter to what we just generated.

```rust title="src/params.rs" ins={16-19}
rp_params! {
    ExampleParams {
        gain: FloatParam {
            name: "Gain",
            value: util::db_to_gain(0.0),
            range: FloatRange::Skewed {
                min: util::db_to_gain(-30.0),
                max: util::db_to_gain(30.0),
                factor: FloatRange::gain_skew_factor(-30.0, 30.0),
            },
            smoother: SmoothingStyle::Logarithmic(50.0),
            unit: " dB",
            value_to_string: formatters::v2s_f32_gain_to_db(2),
            string_to_value: formatters::s2v_f32_gain_to_db(),
        },
        muted: BoolParam {
            name: "Muted",
            value: false
        },
    }
}
```

You can see that the parameters are declared along with their types, default values, and more properties, such as the range, smoother, and formatters. You can specify as many parameters as you like, as long as you include the necessary information, such as names, values, and so on.

<details>
  <summary>Why exactly is this needed?</summary>

The [message](#messages) enums also communicate parameter changes. For this to work:

- It needs to be known what parameters exist and what plain data types they store
- Units, smoothing styles, formatters need to be sent to the GUI
- Parameter changes need to be serialized as JSON
- Parameters need to have a callback attached to them in order to send messages to the GUI when their values change
- TS Bindings for all parameter types need to exist.

You _could_ explicitly define all these things. The amount of boilerplate would be really annoying, though. This is why this macro derives traits, defined the parameter types, and attaches the aforementioned callbacks.

<Aside>
  As practical as this is, one downside of it is that the `new` function of your
  parameters will be generated by React-Plug. I'd love for there to be a more
  flexible solution. If any macro magician wants to help me out with this, file
  a pull request, create an issue, or cast a spell on my codebase ðŸ§™
</Aside>

</details>

We can now use the `muted` parameter in our plugin code. Let's add a simple check that mutes the output if the parameter is set to `true`. We can do this by modifying `src/lib.rs`.

<FileTree>

- gui/
- src/ Plugin code
  - **lib.rs**
  - params.rs
- xtask/

</FileTree>

Let's check the parameter inside the `process()` function. We'll output all zeroes if the `muted` parameter's value is `true`.

```rust title="src/lib.rs" ins={8-13}
fn process(
    &mut self,
    buffer: &mut Buffer,
    _aux: &mut AuxiliaryBuffers,
    _context: &mut impl ProcessContext<Self>,
) -> ProcessStatus {
    for channel_samples in buffer.iter_samples() {
        if self.params.muted.value() {
            for sample in channel_samples {
                *sample = 0.0;
            }
            continue;
        }
        let gain = self.params.gain.smoothed.next();
        for sample in channel_samples {
            *sample *= gain;
        }
    }

    ProcessStatus::Normal
}
```

### Messages

For data that isn't just parameter updates, you can send your own custom IPC messages. These messages are simply enum variants which get serialized as JSON and sent to the WebView hosting the GUI. You can specify your own message types by deriving the `GuiMessage` and `PluginMessage` traits. Some internal messages are then added automatically.

Let's add a `Ping` message that the GUI can send to the plugin, and a `Pong` message that the plugin can then send back.

```rust title="src/lib.rs" ins={3,8}
#[gui_message(params = ExampleParams)]
pub enum GuiMessage {
    Ping,
}

#[plugin_message(params = ExampleParams)]
pub enum PluginMessage {
    Pong,
}
```

We'll handle the `Ping` by responding with a `Pong`. To do this, let's go over to the editor function and add a message handler for the `Ping` message.

### Editor

Inside the `editor` function, the plugin defines its editor. This is where you can
set up your GUI. The `ReactPlugEditor` struct is used to create a new editor.

To handle incoming `Ping` messages, we can just add a message handler to this
editor using `with_message_handler`. The message handler lets you react to inbound
messages from the GUI by passing a closure to it. We'll just respond with a `Pong`
by sending it via the editor channel.

```rust title="src/lib.rs" ins={16-18}
static EDITOR_DIR: Dir = include_dir!("$CARGO_MANIFEST_DIR/gui/dist");

fn editor(&mut self, _async_executor: AsyncExecutor<Self>)
    -> Option<Box<dyn Editor>>
{
    let sender = self.editor_channel.0.clone();

    ReactPlugEditor::new::<GuiMessage>(
        self.params.clone(),
        &EDITOR_DIR,
        self.editor_channel.clone(),
        (800, 600)
    )
    .with_developer_mode(true)
    .with_message_handler(move |message| {
        if let GuiMessage::Ping = message {
            sender.send(PluginMessage::Pong).unwrap();
        }
    })
    .into()
}
```

There are a lot more things you can do with the editor by chaining more methods. We won't go into that here, though. Let's instead move on to the actual GUI.

## GUI

The GUI is written in React. It lives in the `gui` subfolder, as a node package. Let's check it out.

<FileTree>

- **gui/** GUI code
  - src/
    - bindings/ Auto-generated TS bindings
    - App.tsx
    - main.tsx
    - styles.css
  - .eslintrc.cjs
  - .gitignore
  - index.html
  - package.json Package configuration
  - tsconfig.json
  - vite.config.ts
- src/
- xtask/

</FileTree>

If you've worked with React before, this probably seems really familiar. One noteworthy difference is that, in React-Plug, there's a `gui/src/bindings` directory. You won't ever have to directly edit files in this directory. It houses all the automatically generated bindings for our plugin, such as the PluginProvider.

The PluginProvider lets you communicate with your plugin. You can use it by importing it and calling `usePluginContext()`. It contains all parameters, as well as methods for handling and sending messages.

Let's get started by opening up the `App.tsx` file.

<FileTree>

- gui/
  - src/
    - bindings/
    - **App.tsx**
    - main.tsx
    - styles.css
  - ...
- src/
- xtask/

</FileTree>

We can just remove the generated boilerplate and do something else ourselves. We'll start by importing the PluginProvider and loading the plugin context.

```tsx title="gui/src/App.tsx"
import { usePluginContext } from "./bindings/PluginProvider";

function App() {
  const ctx = usePluginContext();

  return <></>;
}

export default App;
```

<details>
  <summary>How does the PluginContext work?</summary>

Your React `App` component is wrapped by a `PluginProvider` component that provides the necessary context. This provider internally abstracts over all plugin/GUI communication. It's automatically generated and contains definitions for all your parameters and messages. The macros we looked at before handle all of that for you.

```tsx title="gui/src/main.tsx" {4,8,10}
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.tsx";
import PluginProvider from "./bindings/PluginProvider.tsx";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <PluginProvider>
      <App />
    </PluginProvider>
  </React.StrictMode>,
);
```

</details>

If you want to make rapid changes to your GUI without constantly re-compiling your plugin, you can use the `dev` command.

```bash
cargo xtask dev <your-plugin>
```

Just load the bundled plugin in your preferred DAW or host. Then, whenever you make changes to your GUI, they'll be reflected in real-time.

The command will build a development version of your plugin that doesn't include the GUI. Instead, this version loads it from a local hot-reloading server. This way, you can make changes to your GUI and see them reflected in real-time. This version of your plugin is obviously not suitable for distribution, but it's great for development.

### Parameters

Let's display the current gain. We can do this by reading the name, value and unit properties of `ctx.parameters.gain`.

```tsx title="gui/src/App.tsx" add={5,9}
import { usePluginContext } from "./bindings/PluginProvider";

function App() {
  const ctx = usePluginContext();
  const gain = ctx.parameters.gain;

  return (
    <div>
      {gain.name}: {gain.value + gain.unit}
    </div>
  );
}

export default App;
```

The `value` actually already has the proper formatting which we supplied in the
`rp_params!` definition.

<Aside title="Limitation on Formatting">
  This only works with `nih_plug`'s internal `v2s_*` formatters! If you supplied
  your own formatter, you'll have to handle formatting yourself in the GUI, too.
</Aside>

Let's add a slider for our "gain" parameter. We can use its raw value, normalization function, and `setValue` function to display the gain value and update it when the slider is tweaked.

```tsx title="gui/src/App.tsx" add={13-23}
import { usePluginContext } from "./bindings/PluginProvider";

function App() {
  const ctx = usePluginContext();
  const gain = ctx.parameters.gain;

  return (
    <div className="container">
      <div>
        {gain.name}: {gain.value + gain.unit}
      </div>

      <input
        type="range"
        className="slider"
        min={0}
        max={1}
        step={0.001}
        value={gain.range.normalize(gain.rawValue)}
        onChange={(e) => {
          gain.setValue(gain.range.unnormalize(Number(e.target.value)));
        }}
      />
    </div>
  );
}

export default App;
```

<details>
  <summary>Why is the min 0 and the max 1?</summary>

Because we want to normalize the gain value within its skewed range.

In the [plugin code](#parameters), we set the gain parameter's range to be skewed. So, in order to properly display its value, we want to show the normalized raw value, which will always be between 0 and 1. When the slider's value changes, we do update the parameter with the un-normalized value of the slider.

</details>

### Messages

You can send messages to the plugin by calling `sendToPlugin()` on the PluginContext. Let's remove everything again and just send that `Ping` message we defined earlier.

```tsx title="gui/src/App.tsx" add={8}
import { usePluginContext } from "./bindings/PluginProvider";

function App() {
  const ctx = usePluginContext();

  return (
    <div>
      <button onClick={() => ctx.sendToPlugin("Ping")}>Send Ping</button>
    </div>
  );
}

export default App;
```

We set the plugin up to respond with a `Pong` every time it receives this message. Let's see if it actually sends a `Pong`. In order to react to plugin messages, you can add a listener for them. In our case, we'll do this inside a React `useEffect`, so that we can unregister the listener, too.

```tsx title="gui/src/App.tsx" add={6, 8-16, 21}
import { usePluginContext } from "./bindings/PluginProvider";
import { useEffect, useState } from "react";

function App() {
  const ctx = usePluginContext();
  const [pongCount, setPongCount] = useState(0);

  useEffect(() => {
    const listener = (message) => {
      if (message === "Pong") setPongCount((prevCount) => prevCount + 1);
    };

    ctx.addMessageListener(listener);

    return () => ctx.removeMessageListener(listener);
  }, [ctx]);

  return (
    <div>
      <button onClick={() => ctx.sendToPlugin("Ping")}>Send Ping</button>
      <div>Pong counter: {pongCount}</div>
    </div>
  );
}

export default App;
```

Now, every time a `Pong` message is received, we'll increment the pong count.

And that's it! You've now seen how to use parameters, messages, and the PluginContext in React-Plug! You can now build your own React-powered audio plugins.
